<!DOCTYPE html>
<meta charset=UTF-8>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>H/2 Progressive test page</title>
<script>function start() {/*it'll be replaced by the next script, if it works*/alert("this browser is not supported")}</script>
<script>
    (function(){
        if (location.protocol == 'http:') {
            location = `https://${location.host}`;
            return;
        }
        const registered = navigator.serviceWorker.register('/sw.js');
        let requests = new Map();
        window.start = function(withPrioritization) {
            registered.then(() => {
                if (isProgressiveJPEGBorked()) {
                    alert("Sorry, Safari does not render JPEG images progressively, and therefore it won't benefit from faster progressive streaming :(");
                }
                requests = new Map(); // reset
                document.body.className = 'testing';
                document.getElementById('intro').setAttribute('hidden', 'hidden');
                document.getElementById('back').removeAttribute('hidden');
                const imglist = document.getElementById('image-list');
                const backButton = document.getElementById('back');
                const reset = function() {
                    document.body.className = '';
                    document.getElementById('intro').removeAttribute('hidden');
                    imglist.setAttribute('hidden', 'hidden');
                    backButton.setAttribute('hidden', 'hidden');
                    document.getElementById('graph').setAttribute('hidden', 'hidden');
                };
                imglist.onclick = reset;
                backButton.onclick = reset;

                const numbers = [];
                for (let n = 1; n <= 23; n++) numbers.push(n);
                for (let i = 22; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                }
                numbers.push(24);
                let imagesHTML = '';
                const cachebust = Date.now() % 10000;
                for(const n of numbers) {
                    const baseurl = `https://jpeg.speedcf.com/worker?image=cat/${n}.jpg&cachebust=${cachebust}${withPrioritization ? '' : 'nopri=1'}`;
                    imagesHTML += `<img src="${baseurl}&size=300" width="300" height="300" srcset="${baseurl}&size=300 300w, ${baseurl}&size=600 600w" alt="cat">`;
                }
                imglist.innerHTML = imagesHTML;
                imglist.removeAttribute('hidden');
            })
        }
        function isProgressiveJPEGBorked() {
            // unfortunately, progressive rendering can't be feature-detected (it's not about format support, but on-screen appearance)
            // and Safari's popularity and complete lack of partial rendering warrants a warning
            const ua = navigator.userAgent;
            return /AppleWebKit.*Safari\/6/.test(ua) && !/Chrome|Edg|Android/.test(ua);
        }
        let waiting;
        // SW will report each chunk of data received
        navigator.serviceWorker.addEventListener('message', function addData(event) {
            const url = event.data[0];
            if (!requests.has(url)) {
                requests.set(url, []);
            }
            const log = requests.get(url);
            log.push(event.data);
            // Throttled refresh of the graph
            if (!waiting) {
                waiting = true;
                requestAnimationFrame(() => {
                    waiting = false;
                    refresh()
                }, 1);
            }
        });
        function frac(start, end, value) {
            const size = end - start;
            return Math.min(size, Math.max(0, value - start)) / size;
        }
        // Builds SVG polygons for the speed-index-like graph based on request log
        function refresh() {
            const width = 300;
            const height = 100;
            const progressive = true;

            let startedLine = `0,${height}`;
            let visuallyCompleteLine = `0,${height}`;
            let goodEnoughLine = `0,${height}`;
            let doneLine = `0,${height}`;
            function addDataPoint(timeFrac, inFlight, totalItems) {
                let startedTotal = 0;
                let visuallyCompleteTotal = 0;
                let goodEnoughTotal = 0;
                let doneTotal = 0;
                for(const doneFrac of inFlight.values()) {
                    if (doneFrac > 177/50000) startedTotal++; // header size/expected file size
                    // This is based on typical DC size in a progressive JPEG
                    visuallyCompleteTotal += progressive ? frac(0.1, 0.18, doneFrac) : frac(0.01, 1, doneFrac);
                    // This is based on typical size of AC scans for all channels, with majority of bits/coefficients available
                    goodEnoughTotal += progressive ? frac(0.45, 0.6, doneFrac) : frac(0.85, 1, doneFrac);
                    doneTotal += progressive ? frac(0.5, 1, doneFrac) : frac(0.99, 1, doneFrac);
                }
                startedLine += ` ${width * timeFrac},${height - height * startedTotal / totalItems - 0.25}`;
                visuallyCompleteLine += ` ${width * timeFrac},${height - height * visuallyCompleteTotal / totalItems}`;
                goodEnoughLine += ` ${width * timeFrac},${height - height * goodEnoughTotal / totalItems}`;
                doneLine += ` ${width * timeFrac},${height - height * doneTotal / totalItems}`;
            }

            const byTime = [];
            for(const log of requests.values()) {
                const maxBytes = Math.max(1, log[log.length-1][2]);
                for(const [url, timestamp, bytes] of log) {
                    byTime.push([timestamp, url, bytes/maxBytes]);
                }
                const [url, timestamp, bytes] = log[log.length-1];
                byTime.push([timestamp+5, url, 1]); // dupe the last event so that it's not ~0px wide in the graph
            }
            byTime.sort();
            const minTime = byTime[0][0];
            const maxTime = byTime[byTime.length-1][0];
            const duration = Math.max(1, maxTime - minTime);

            const totalSize = Math.max(6, requests.size);
            const inFlight = new Map();
            for(const [timestamp, url, fracDone] of byTime) {
                inFlight.set(url, fracDone);
                const timeFrac = (timestamp - minTime) / duration;
                addDataPoint(timeFrac, inFlight, totalSize)
            }
            startedLine += ` ${width},${height}`;
            visuallyCompleteLine += ` ${width},${height}`;
            goodEnoughLine += ` ${width},${height}`;
            doneLine += ` ${width},${height}`;
            document.getElementById('startedLine').setAttribute('points', startedLine);
            document.getElementById('visuallyCompleteLine').setAttribute('points', visuallyCompleteLine);
            document.getElementById('goodEnoughLine').setAttribute('points', goodEnoughLine);
            document.getElementById('doneLine').setAttribute('points', doneLine);
            document.getElementById('graph').removeAttribute('hidden');
            const svglink = document.getElementById('svglink');
            svglink.download = 'cloudflare-progressive.svg';
            svglink.href = `data:image/svg,${encodeURIComponent(svglink.innerHTML)}`;
        }
    })();
</script>
<style>
body {
    background: #fff;
    color: #000;
    margin: 0; padding: 0;
    font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif;
    font-size: 0.875em;
    font-weight: 300;
    line-height: 1.5;
}
body.testing {
    background: #555;
    color: #fff;
}
#image-list {
    border: 2px solid black;
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    list-style: none;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-auto-rows: 1fr;
}
#image-list li {
    width: 100%;
    margin: 0;
    padding: 0;
    display: block;
}
@media (min-aspect-ratio: 5/2) {
    #image-list {
        grid-template-columns: repeat(6, 1fr);
    }
}
@media (max-aspect-ratio: 4/3) {
    #image-list {
        grid-template-columns: repeat(4, 1fr);
    }
}
@media (max-aspect-ratio: 1/1) {
    #image-list {
        grid-template-columns: repeat(3, 1fr);
    }
}
@media (max-aspect-ratio: 1/3) {
    #image-list {
        grid-template-columns: repeat(2, 1fr);
    }
}
#image-list img {
    border: 2px solid black;
    box-sizing: border-box;
    object-fit: cover;
    width: 100%;
    max-height: 100%;
    display: block;
}
#graph svg {
    width: 100%;
    height: auto;
    display: block;
    margin: 0; padding: 0;
    opacity: 0.95;
}
#graph span {
    display: inline-block;
    width: 0.75em;
    height: 0.75em;
    content: "";
    vertical-align: middle;
    box-shadow: 0 1px 1px rgba(0,0,0,0.1);
    box-sizing: border-box;
    background-clip: border-box;
    margin: 0 0.1ex 0 0;
}
#graph div {
    position: absolute;
}
#graph div.top {
    top: 20px;
    left: 20px;
    color: white;
    text-shadow: 0 1px 1px black;
}
#graph div.bot {
    bottom: 20px;
    right: 20px;
    color: black;
    text-shadow: 1px 1px 0 white, 0px -1px 2px white;
    text-align: right;
}
#graph {
    overflow: hidden;
    position: fixed;
    bottom: 20px;
    left: 20px;
    right: 20px;
    font-size: 0.8em;
    border: 1px solid black;
    max-width: 800px;
}
#back {
    overflow: hidden;
    position: fixed;
    top: 20px;
    left: 20px;
    color: #fff;
    text-shadow: 0 1px 1px black;
    background: rgba(0,0,0,0.3);
    padding: 1em;
    border: 1px solid black;
    cursor: pointer;
}
@media (max-width: 480px) {
    #graph {
        font-size: 0.7em;
        bottom: 10px;
        left: 10px;
        right: 10px;
    }
}
*[hidden] {
    display: none !important;
}
#intro {
    max-width: 762px;
    padding: 1em 2em;
    margin: 0 auto;
}
#intro h1 {
    margin: 0;
}
#intro h1 img {
    border: 0;
    width: 100%;
    height: auto;
    display: block;
    color: #727bb3;
}
button {
    display: block;
    margin: 1em auto;
    font-size: 1.25em;
    border: none;
    border-radius: 5px;
    padding: 0.5em 1em;
    cursor: pointer;
    text-shadow: 0 1px 0 rgba(255,255,255,0.3);
}
button.orange {
    background: #FAAD3F;
    border: 1px solid #c87;
    color: #000;
    box-shadow: inset -2px -4px 7px rgba(180,50,0,0.15);
}
button.gray {
    background: #bbb;
    border: 1px solid #888;
    color: #000;
    box-shadow: inset -3px -5px 10px rgba(0,0,0,0.1);
}
button:hover {
    box-shadow: none;
    border-color: #000;
}
</style>
<div id=intro>
<h1><img width="761" height="310" src="logo.png" alt="HTTP/2 Parallel Progressive Streaming"></h1>
This is a demo page of Cloudflare's HTTP/2 prioritization feature applied to progressive JPEG images. It&nbsp;makes all images on the page appear to load quicker by&nbsp;prioritizing their progressive "previews" on&nbsp;the network level. <a href="https://blog.cloudflare.com/parallel-streaming-of-progressive-images/">See the blog post for&nbsp;details</a>.

<noscript><p>JavaScript is required for this demo (but it's not required for the HTTP/2 prioritization).</p></noscript>

<p><button class="orange" onclick="start(true)" type="button">Start with prioritization</button></p>
<p><button class="gray" onclick="start(false)" type="button">Start without prioritization</button></p>

<p>The demo will show a graph of page's overall visual progress over time. Graph with a large amount of color (orange and green) shows good utilization of progressive rendering. A linear mostly black-and-white graph means sequential loading. The data is based on loading progress measured by a ServiceWorker running in the browser. Actual on-screen rendering may be different due to refresh throttling and quality of JPEG decoding implementation.</p>
</div>


<div hidden id="back" role=button>
    ‹ Start over
</div>

<div hidden id="graph">
    <a id=svglink><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 100">
        <rect width="100%" height="100%" fill="#000" opacity="0.3" />
        <polygon id="startedLine" fill="#000" opacity="0.8" fill-opacity="0.5" stroke="#fff" stroke-width="0.5px" stroke-dasharray="1"></polygon>
        <polygon id="visuallyCompleteLine" fill="#FAAD3F" stroke="none"></polygon>
        <polygon id="goodEnoughLine" fill="#73ff0c" stroke="none"></polygon>
        <polygon id="doneLine" fill="#fff" stroke="none"></polygon>
    </svg></a>
    <div class="top">
        <span style="border: 1px dotted #ddd; background: rgba(0,0,0,0.2); box-shadow: 1px 1px 0 rgba(0,0,0,0.25), inset 1px 1px 0 rgba(0,0,0,0.25)"></span> size known <br>
        <span style="background: #FAAD3F"></span> rough preview <br>
        <span style="background: #73ff0c"></span> looks done <br>
        <span style="background: #fff"></span> done
    </div>
    <div class="bot">
        time &rarr;
        <br>
        visual completion &uarr;
    </div>
</div>
<ul hidden id=image-list>
</ul>
